import numpy as np

def sample_spheres(directions=[32,48,64], alpha=0.5, tolerance=10e-10,
				   iterations=10000, verbose=False):
	"""
	Create an evenly distributed sampling around a sphere based on
	electrostatic repulsion. Attempts to create even sampling for
	multi-sphere sets using the algorithm and cost functions described
	in:
	Design of Multishell Sampling Schemes with Uniform Coverage in Diffusion
	MRI. Emmanuel Caruyer et al. Magnetic Resonance in Medicine 69:1534-1540
	(2013)

	INPUTS:
	directions: list of number of points to be distributed on each shell

	tolerance: Minimum change in cost function after which the algorithm
			   terminates

	iterations: number of iterations to run before terminating the algorithm
		    (the previous tolerance is usually satisfied before this is
		     necessary)

	alpha: Weighting of intrasphere distribution vs. intersphere distribution

	OUTPUT:
	shells: list of lists containing vectors for each point on each sphere
	"""

	number_of_shells = len(directions)
	shells = []

	# Start with a random set of directions
	for i in range(number_of_shells):
		shell = 2.0 * np.random.ranf([directions[i], 3]) - 1.0

		# Make Unit Vectors
		for j in range(directions[i]):
			shell[j,:] /= np.linalg.norm(shell[j,:])

		# Add new points to shell
		shells.append(shell)


	tolerance_met = False
	force_scale_factor = 100
	prev_cost_function = 0
	iteration = 0

	while (iteration <= iterations and tolerance_met == False):
		movements = np.zeros((np.sum(directions), 3))
		direction_index = 0

		# Calculate Intrashell forces/movements
		for i in range(number_of_shells):
			for j in range(directions[i]):
				# Find Direction and Magnitude of Movement
				current_point = shells[i][j,:]

				for k in range(directions[i]):
					if (k != j):
						distance = current_point - shells[i][k,:]
						direction = distance / np.linalg.norm(distance)

						movements[direction_index,:] += (direction / (np.linalg.norm(distance)**2) /
														 	          (number_of_shells * directions[i] ** 2))


				direction_index += 1

		direction_index = 0
		# Calculate Intershell forces
		for i in range(number_of_shells):
			for j in range(directions[i]):
				current_point = shells[i][j,:]

				for k in range(number_of_shells):
					for m in range(directions[k]):
						if ((i == k) and (j == m)) is False:
							distance = current_point - shells[k][m,:]
							direction = (distance) / np.linalg.norm(distance)

							movements[direction_index,:] += (direction / (np.linalg.norm(distance)**2) /
															             (np.sum(directions) ** 2))

				direction_index += 1

		# Calculate Total force as cost fucntion
		cost_function = 0
		for i in range(np.sum(directions)):
			cost_function += np.linalg.norm(movements[i,:])

		# Check if current move is too big
		if cost_function >= prev_cost_function:
			force_scale_factor *= 0.95

		delta_cost_function = np.absolute(cost_function-prev_cost_function)
		if (delta_cost_function < tolerance):
			tolerance_met = True

		# Update cost function for next iteration check
		prev_cost_function = cost_function

		# Move Points
		direction_index = 0
		for i in range(number_of_shells):
			for j in range(directions[i]):
				shells[i][j,:] += force_scale_factor * movements[direction_index,:]
				shells[i][j,:] /= np.linalg.norm(shells[i][j,:])
				direction_index += 1

		if verbose:
			print("Iteration: " + str(iteration) + ", Cost Function: " + str(delta_cost_function))
		iteration += 1

	return shells



def optimize_direction_order(shells, b_values):
	"""
	Change the order of a direction set generated by sample_spheres in order
	to have nearly optimal sampling if the experiment ends early.

	INPUTS:
	shells: output of sample_spheres, list of list containing directions
	b_values: list of b_values for each shells

	OUTPUT:
	bvecs: list of directions with in optimized order
	bvals: b-values of the optimized direction set
	"""

	# Determine total number of directions and allocate space
	number_of_dirs = 0
	for i in range(len(shells)):
		number_of_dirs += len(shells[i])

	bvecs = np.zeros((number_of_dirs, 3))
	bvals = np.zeros((number_of_dirs, 1))

	# Find the ratio of directions in each shell relative to first shell
	dir_ratio = []
	number_left = []
	number_to_add = np.zeros((len(shells[i])))
	for i in range(len(shells)):
		dir_ratio.append(int(len(shells[i]) / len(shells[0])))
		number_left.append(len(shells[i]))

	# Determine order to add from each shell
	shell_index = []
	total_number_left = number_of_dirs
	while (total_number_left > 0):
		for j in range(len(dir_ratio)):
			number_to_add[j] += dir_ratio[j]
			loop_size = int(number_to_add[j])

			if(loop_size > 0):
				for k in range(loop_size):
					if(number_left[j] > 0):
						shell_index.append(j)
						number_left[j] -= 1
						total_number_left -= 1

			number_to_add[j] -= loop_size

	# Start with first direction, add directions that add least total force
	bvecs = np.zeros((number_of_dirs,3))
	bvals = np.zeros(number_of_dirs)
	bvecs[0,:] = shells[0][0,:]
	bvals[0] = b_values[shell_index[0]]
	shells[0] = np.delete(shells[0],0,0)

	for i in range(1,len(shell_index)):
		# Set force to impossible value for first iteration
		force = -1.0

		for j in range(len(shells[shell_index[i]])):
			temp_force = np.sum(1 / np.linalg.norm((bvecs[0:i,:] - shells[shell_index[i]][j,:]),axis=1)**2)

			if (temp_force < force or force == -1.0):
				force = temp_force
				lowest_index = j

		bvecs[i,:] = shells[shell_index[i]][lowest_index,:]
		bvals[i] = b_values[shell_index[i]]

		shells[shell_index[i]] = np.delete(shells[shell_index[i]],lowest_index,0)

	return bvecs,bvals



def add_b_zeros(bvecs, bvals, b0_spacing=10, leading_b0s=1):
	"""
	Intersperse b=0 images into diffusion vector set

	INPUTS:
	bvecs: array of b-vectors without b-zeros added
	bvals: list of b-values without b-zeros added
	b0_spacing: Number of diffusion weighted images between each b-zeros
	leading_b0s: Number of b=0 images at the beginning of scan

	OUTPUTS:
	bvecs_zeros: array of b-vectors wth b-zeros added
	bvals_zeros: list of b-values with b-zeros added
	"""

	# Start with list of b-zeros
	bvals_zeros = []
	non_b_zeros_remaining = len(bvals)
	leading_b0s_remaining = leading_b0s
	count = b0_spacing
	bval_index = 0
	while(non_b_zeros_remaining > 0):
		while(leading_b0s_remaining > 0):
			bvals_zeros.append(0)
			leading_b0s_remaining -= 1

		if(count != 0):
			bvals_zeros.append(bvals[bval_index])
			bval_index += 1
			non_b_zeros_remaining -= 1
			count -= 1
		else:
			bvals_zeros.append(0)
			count = b0_spacing

		if(non_b_zeros_remaining == 0 and bvals_zeros[-1:] != 0):
			bvals_zeros.append(0)

	# Update b-vectors
	bvecs_zeros = np.zeros((len(bvals_zeros), 3))
	bvec_index = 0
	for i in range(len(bvals_zeros)):
		if(bvals_zeros[i] == 0):
			bvecs_zeros[i,:] = 0
		else:
			bvecs_zeros[i,:] = bvecs[bvec_index]
			bvec_index += 1

	return bvecs_zeros, bvals_zeros



def write_siemens_direction_file(bvecs,bvals,out_path):
	"""
	Write a .dvs file to be used by a Siemens scanner for a diffusion scanner

	INPUTS:
	bvecs: list of unit vectors of diffusion directions
	bvals: list of b-values corresponding to each of the above directions
	out_path: name and location of the .dvs file
	"""

	maxB = np.max(bvals)
	for i in range(len(bvals)):
		bvecs[i,:] = bvecs[i,:] * np.sqrt(float(bvals[i]) / float(maxB))

	if out_path == "None":
		f1 = tkFileDialog.asksaveasfile(mode='w',defaultextension=".dvs")
	else:
		f1 = open(out_path, 'w+')

	f1.write('[Directions=%d]\nCoordinateSystem = XYZ\nNormalisation = None\n' % len(bvals))

	for i in range(len(bvals)):
		f1.write('vector[ %d] = ( %f, %f, %f )\n' % (i, bvecs[i,0], bvecs[i,1], bvecs[i,2]))

	f1.close()

def write_phillips_direction_file(bvecs,bvals,out_path):
	"""
	Write a .txt file to be used by a Siemens scanner for a diffusion scanner

	INPUTS:
	bvecs: list of unit vectors of diffusion directions
	bvals: list of b-values corresponding to each of the above directions
	out_path: name and location of the .txt file
	"""

	for i in range(len(bvals)):
		if (bvals[i] == 0 and i == 0):
			bvecs[i,:] = np.random.rand(1,3)
			bvecs[i,:] = bvecs[i,:] / np.linalg.norm(bvecs[i,:])
		elif (bvals[i] == 0 and i != 0):
			bvals[i] = 0.01
			bvecs[i,:] = np.random.rand(1,3)
			bvecs[i,:] = bvecs[i,:] / np.linalg.norm(bvecs[i,:])

	if out_path == "None":
		f1 = tkFileDialog.asksaveasfile(mode='w',defaultextension=".txt")
	else:
		f1 = open(out_path, 'w+')

	for i in range(len(bvals)):
		f1.write('%f %f %f %f\n' % (bvecs[i,0], bvecs[i,1], bvecs[i,2], bvals[i]))

	f1.close()


### TODO #######################################################################
def write_ge_direction_file(bvecs,bvals,out_path):
	"""
	Write a .dat file to be used by a GE scanner for a diffusion scan

	INPUTS:
	bvecs: list of unit vectors of diffusion directions
	bvals: list of b-values corresponding to each of the above directions
	out_path: name and location of the .dat file
	"""

def write_bruker_direction_file(bvecs,bvals,out_path):
	"""
	Write a .dat file to be used by a Bruker scanner for a diffusion scan

	INPUTS:
	bvecs: list of unit vectors of diffusion directions
	bvals: list of b-values corresponding to each of the above directions
	out_path: name and location of the .dat file
	"""
################################################################################
